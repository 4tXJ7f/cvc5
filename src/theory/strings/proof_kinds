
//======================== Core solver

// ======== Concat eq
// Children: (P1:(= (str.++ t1 ... tn t) (str.++ t1 ... tn s)))
// Arguments: (b), indicating if reverse direction
// ---------------------
// Conclusion: (= t s)
//
// Notice that t or s may be empty, in which case they are implicit in the
// concatenation above. For example, if
// P1 concludes (= x (str.++ x z)), then
// (CONCAT_EQ P1 :args false) concludes (= "" z)
//
// Also note that constants are split, such that if
// P1 concludes (= (str.++ "abc" x) (str.++ "a" y)), then 
// (CONCAT_EQ P1 :args false) concludes (= (str.++ "bc" x) y)
// This splitting is done only for constants such that Word::splitConstant
// returns non-null.
proofrule CONCAT_EQ 1 1 ::CVC4::theory::strings::StringsProofRuleChecker

// ======== Concat unify
// Children: (P1:(= (str.++ t1 t2) (str.++ s1 s2)),
//            P2:(= (str.len t1) (str.len s1)))
// Arguments: (b), indicating if reverse direction
// ---------------------
// Conclusion: (= t1 s1)
proofrule CONCAT_UNIFY 2 1 ::CVC4::theory::strings::StringsProofRuleChecker

// ======== Concat conflict
// Children: (P1:(= (str.++ c1 t) (str.++ c2 s)))
// Arguments: (b), indicating if reverse direction
// ---------------------
// Conclusion: false
// Where c1, c2 are constants such that Word::splitConstant(c1,c2,index,b) 
// is null, in other words, neither is a prefix of the other.
proofrule CONCAT_CONFLICT 2 1 ::CVC4::theory::strings::StringsProofRuleChecker

// ======== Concat split
// Children: (P1:(= (str.++ t1 t2) (str.++ s1 s2)),
//            P2:(not (= (str.len t1) (str.len s1))))
// Arguments: (false)
// ---------------------
// Conclusion: (or (= t1 (str.++ s1 r_t)) (= s1 (str.++ t1 r_s)))
// where
//   r_t = (witness ((z String)) (= z (suf t1 (str.len s1)))),
//   r_s = (witness ((z String)) (= z (suf s1 (str.len t1)))).
//
// or the reverse form of the above:
//
// Children: (P1:(= (str.++ t1 t2) (str.++ s1 s2)),
//            P2:(not (= (str.len t2) (str.len s2))))
// Arguments: (true)
// ---------------------
// Conclusion: (or (= t2 (str.++ r_t s2)) (= s2 (str.++ r_s t2)))
// where
//   r_t = (witness ((z String)) (= z (pre t2 (- (str.len t2) (str.len s2))))),
//   r_s = (witness ((z String)) (= z (pre s2 (- (str.len s2) (str.len t2))))).
//
// Above, (suf x n) is shorthand for (str.substr x n (- (str.len x) n)) and
// (pre x n) is shorthand for (str.substr x 0 n).
proofrule CONCAT_SPLIT 2 1 ::CVC4::theory::strings::StringsProofRuleChecker

// ======== Concat constant split
// Children: (P1:(= (str.++ t1 t2) (str.++ c s2)),
//            P2:(not (= (str.len t1) 0)))
// Arguments: (false)
// ---------------------
// Conclusion: (= t1 (str.++ c r))
// where
//   r = (witness ((z String)) (= z (suf t1 1))).
//
// or the reverse form of the above:
//
// Children: (P1:(= (str.++ t1 t2) (str.++ s1 c)),
//            P2:(not (= (str.len t2) 0)))
// Arguments: (true)
// ---------------------
// Conclusion: (= t2 (str.++ r c))
// where
//   r = (witness ((z String)) (= z (pre t2 (- (str.len t2) 1)))).
proofrule CONCAT_CSPLIT 2 1 ::CVC4::theory::strings::StringsProofRuleChecker

// ======== Concat length propagate
// Children: (P1:(= (str.++ t1 t2) (str.++ s1 s2)),
//            P2:(> (str.len t1) (str.len s1)))
// Arguments: (false)
// ---------------------
// Conclusion: (= t1 (str.++ s1 r_t))
// where
//   r_t = (witness ((z String)) (= z (suf t1 (str.len s1))))
//
// or the reverse form of the above:
//
// Children: (P1:(= (str.++ t1 t2) (str.++ s1 s2)),
//            P2:(> (str.len t2) (str.len s2)))
// Arguments: (false)
// ---------------------
// Conclusion: (= t2 (str.++ r_t s2))
// where
//   r_t = (witness ((z String)) (= z (pre t2 (- (str.len t2) (str.len s2))))).
proofrule CONCAT_LPROP 2 1 ::CVC4::theory::strings::StringsProofRuleChecker

// ======== Concat constant propagate
// Children: (P1:(= (str.++ t1 w1 t2) (str.++ w2 s)),
//            P2:(not (= (str.len t1) 0)))
// Arguments: (false)
// ---------------------
// Conclusion: (= t1 (str.++ w3 r)) 
// where
//   w1, w2, w3, w4 are words,
//   w3 is (pre w2 p),
//   w4 is (suf w2 p),
//   p = Word::overlap((suf w2 1), w1),
//   r = (witness ((z String)) (= z (suf t1 (str.len w3)))).
// In other words, w4 is the largest suffix of (suf w2 1) that can contain a
// prefix of w1; since t1 is non-empty, w3 must therefore be contained in t1.
//
// or the reverse form of the above:
//
// Children: (P1:(= (str.++ t1 w1 t2) (str.++ s w2)),
//            P2:(not (= (str.len t2) 0)))
// Arguments: (true)
// ---------------------
// Conclusion: (= t2 (str.++ r w3)) 
// where
//   w1, w2, w3, w4 are words,
//   w3 is (suf w2 (- (str.len w2) p)),
//   w4 is (pre w2 (- (str.len w2) p)),
//   p = Word::roverlap((pre w2 (- (str.len w2) 1)), w1),
//   r = (witness ((z String)) (= z (pre t2 (- (str.len t2) (str.len w3))))).
// In other words, w4 is the largest prefix of (pre w2 (- (str.len w2) 1)) that
// can contain a suffix of w1; since t2 is non-empty, w3 must therefore be
// contained in t2.
proofrule CONCAT_CPROP 1 1 ::CVC4::theory::strings::StringsProofRuleChecker

// ======== Length positive
// Children: none
// Arguments: (t)
// ---------------------
// Conclusion: (or (and (= (str.len t) 0) (= t "")) (> (str.len t 0)))
proofrule LENGTH_POS 0 1 ::CVC4::theory::strings::StringsProofRuleChecker

// ======== Length non-empty
// Children: (P1:(not (= t "")))
// Arguments: none
// ---------------------
// Conclusion: (not (= (str.len t) 0))
proofrule LENGTH_NON_EMPTY 1 0 ::CVC4::theory::strings::StringsProofRuleChecker

//======================== Extended functions

// ======== Contains not equal
// Children: (P1:(not (str.contains s t)))
// Arguments: none
// -------------------
// Conclusion: (not (= s t))
proofrule CTN_NOT_EQUAL 1 0 ::CVC4::theory::strings::StringsProofRuleChecker

// ======== Reduction
// Children: none
// Arguments: (t)
// ---------------------
// Conclusion: (and R (= t y)) 
// where y = StringsPreprocess::reduce(t, R, ...).
// In other words, R is the reduction predicate for extended term t, and y is
//   (witness ((z T)) (= z t))
// Notice that the free variables of R are y and the free variables of t.
proofrule STRINGS_REDUCTION 0 1 ::CVC4::theory::strings::StringsProofRuleChecker

// ======== Eager Reduction
// Children: none
// Arguments: (t, id?)
// ---------------------
// Conclusion: R
// where R = StringsPreprocess::eagerReduce(t, id).
proofrule STRINGS_EAGER_REDUCTION 0 1 ::CVC4::theory::strings::StringsProofRuleChecker

//======================== Regular expressions

// ======== Regular expression intersection
// Children: (P1:(str.in.re t R1), ..., Pn:(str.in.re t Rn))
// Arguments: none
// ---------------------
// Conclusion: (str.in.re t (re.inter R1 ... Rn))
proofrule RE_INTER 2: 0 ::CVC4::theory::strings::StringsProofRuleChecker

// ======== Regular expression unfold positive
// Children: (P:(str.in.re t R)) 
// Arguments: none
// ---------------------
// Conclusion:(RegExpOpr::reduceRegExpPos((str.in.re t R))),
// corresponding to the one-step unfolding of the premise.
proofrule RE_UNFOLD_POS 1 0 ::CVC4::theory::strings::StringsProofRuleChecker

// ======== Regular expression unfold negative
// Children: (P:(not (str.in.re t R)))
// Arguments: none
// ---------------------
// Conclusion:(RegExpOpr::reduceRegExpNeg((not (str.in.re t R)))), 
// corresponding to the one-step unfolding of the premise.
proofrule RE_UNFOLD_NEG 1 0 ::CVC4::theory::strings::StringsProofRuleChecker

// ======== Regular expression unfold negative concat fixed
// Children: (P:(not (str.in.re t R)))
// Arguments: none
// ---------------------
// Conclusion:(RegExpOpr::reduceRegExpNegConcatFixed((not (str.in.re t R)),L,i)) 
// where RegExpOpr::getRegExpConcatFixed((not (str.in.re t R)), i) = L.
// corresponding to the one-step unfolding of the premise, optimized for fixed
// length of component i of the regular expression concatenation R.
proofrule RE_UNFOLD_NEG_CONCAT_FIXED 1 0 ::CVC4::theory::strings::StringsProofRuleChecker

