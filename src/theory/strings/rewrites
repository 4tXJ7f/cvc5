(define-rule str-eq-refl ((t String)) (= t t) true)
(define-rule str-eq-symm ((t String) (s String)) (= t s) (= s t))


(define-rule str-concat-flatten ((xs String :list) (s String) (ys String :list) (zs String :list)) (str.++ xs (str.++ s ys) zs) (str.++ xs s ys zs))


(define-rule substr-empty-str ((n Int) (m Int)) (str.substr "" n m) "")

(define-cond-rule str-len-replace-inv ((t String) (s String) (r String)) 
  (= (str.len s) (str.len r))
  (str.len (str.replace t s r))
  (str.len t))

(define-rule re-in-empty ((t String)) (str.in_re t re.none) false)
(define-rule re-in-sigma ((t String)) (str.in_re t re.allchar) (= (str.len t) 1))
(define-rule re-in-cstring ((t String) (s String)) (str.in_re t (str.to_re s)) (= t s))

(define-cond-rule concat-clash ((s1 String) (s2 String :list) (t1 String) (t2 String :list))
  (and (not (= s1 t1)) (= (str.len s1) (str.len t1)))
  (= (str.++ s1 s2) (str.++ t1 t2))
  false)


(define-rule str-concat-emp ((xs String :list) (ys String :list)) (str.++ xs "" ys) (str.++ xs ys))

; Regular expression rules
(define-rule re-concat-emp ((xs RegLan :list) (ys RegLan :list)) (re.++ xs (str.to_re "") ys) (re.++ xs ys))

(define-rule re-concat-flatten ((xs RegLan :list) (s RegLan) (ys RegLan :list) (zs RegLan :list)) (re.++ xs (re.++ s ys) zs) (re.++ xs s ys zs))

(define-rule re-concat-star-swap ((xs RegLan :list) (r RegLan) (ys RegLan :list)) (re.++ xs r (re.* r) ys) (re.++ xs (re.* r) r ys))

